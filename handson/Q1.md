Got it! You want a **hands-on interview question** that tests a candidate on **Spring Boot REST APIs with full CRUD, search, pagination**, and **React integration**. Here’s a well-structured example:

---

### **Interview Task: Book Management System**

#### **Problem Statement**

Build a simple Book Management application with the following requirements:

---

### **Backend (Spring Boot)**

**Entity:** `Book`

```java
Long id
String title
String author
String genre
Double price
```

**Requirements:**

1. **CRUD Operations** (Create, Read, Update, Delete):

   * `POST /books` → Create a book
   * `GET /books/{id}` → Get book by ID
   * `PUT /books/{id}` → Update book by ID
   * `DELETE /books/{id}` → Delete book by ID

2. **Search & Pagination:**

   * `GET /books` → Fetch all books with optional query parameters:

     * `title` → filter by title (partial match)
     * `author` → filter by author (partial match)
     * `page` → page number (default 0)
     * `size` → page size (default 10)
   * Example: `/books?title=Java&author=Smith&page=0&size=5`

3. **Response Format:**
   Include pagination metadata:

   ```json
   {
       "content": [ ...books... ],
       "page": 0,
       "size": 5,
       "totalElements": 20,
       "totalPages": 4
   }
   ```

4. **Validation:**

   * Title, Author: not null
   * Price: must be positive

---

### **Frontend (React)**

**Requirements:**

1. **Display All Books**

   * Use a table or list to display books with pagination.
   * Show columns: Title, Author, Genre, Price, Actions.

2. **Search Functionality**

   * Input fields to search by Title and Author.
   * Fetch filtered data from backend API.

3. **CRUD Operations**

   * Add new book (form with validation)
   * Edit book details
   * Delete a book
   * Update the UI dynamically after operations.

4. **Pagination Controls**

   * Next, Previous, Page Numbers
   * Fetch data from backend with correct page & size.

5. **Error Handling**

   * Show user-friendly messages on failures.

---

### **Bonus Points**

* Use **Spring Data JPA** for repository and pagination.
* Use **Axios** or **Fetch API** in React.
* Use **React Hooks** (`useState`, `useEffect`) for state management.
* Optional: Implement **sorting** by price or title.

---

### **Evaluation Criteria**

1. Correct API implementation (CRUD, search, pagination)
2. React integration with backend API
3. Clean code structure
4. Proper error handling
5. UI usability and clarity
6. Bonus: Validation, sorting, and responsive design

---

Perfect! I’ll provide a **starter template** for both **Spring Boot backend** and **React frontend** that implements **CRUD, search, and pagination**. This will serve as a hands-on assignment for candidates.

---

## **1. Spring Boot Backend**

**Dependencies** (in `pom.xml`):

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
</dependencies>
```

**application.properties**

```properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.h2.console.enabled=true
spring.jpa.hibernate.ddl-auto=update
```

**Book Entity**

```java
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Positive;

@Entity
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    private String title;

    @NotBlank
    private String author;

    private String genre;

    @Positive
    private Double price;

    // Getters and Setters
}
```

**Book Repository**

```java
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

public interface BookRepository extends JpaRepository<Book, Long> {
    Page<Book> findByTitleContainingAndAuthorContaining(String title, String author, Pageable pageable);
}
```

**Book Controller**

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.*;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/books")
public class BookController {

    @Autowired
    private BookRepository bookRepository;

    @PostMapping
    public Book createBook(@Validated @RequestBody Book book) {
        return bookRepository.save(book);
    }

    @GetMapping("/{id}")
    public ResponseEntity<Book> getBookById(@PathVariable Long id) {
        return bookRepository.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PutMapping("/{id}")
    public ResponseEntity<Book> updateBook(@PathVariable Long id, @Validated @RequestBody Book updatedBook) {
        return bookRepository.findById(id)
                .map(book -> {
                    book.setTitle(updatedBook.getTitle());
                    book.setAuthor(updatedBook.getAuthor());
                    book.setGenre(updatedBook.getGenre());
                    book.setPrice(updatedBook.getPrice());
                    return ResponseEntity.ok(bookRepository.save(book));
                })
                .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteBook(@PathVariable Long id) {
        return bookRepository.findById(id)
                .map(book -> {
                    bookRepository.delete(book);
                    return ResponseEntity.ok().<Void>build();
                })
                .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping
    public Page<Book> getBooks(
            @RequestParam(defaultValue = "") String title,
            @RequestParam(defaultValue = "") String author,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size
    ) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("title").ascending());
        return bookRepository.findByTitleContainingAndAuthorContaining(title, author, pageable);
    }
}
```

✅ This gives a full **backend REST API** with CRUD, search, and pagination.

---

## **2. React Frontend (Using Axios)**

**Install dependencies**

```bash
npx create-react-app book-management
cd book-management
npm install axios
```

**BookService.js**

```javascript
import axios from 'axios';

const API_URL = "http://localhost:8080/books";

export const getBooks = (title, author, page, size) => {
    return axios.get(API_URL, { params: { title, author, page, size } });
};

export const getBookById = (id) => axios.get(`${API_URL}/${id}`);
export const createBook = (book) => axios.post(API_URL, book);
export const updateBook = (id, book) => axios.put(`${API_URL}/${id}`, book);
export const deleteBook = (id) => axios.delete(`${API_URL}/${id}`);
```

**App.js**

```javascript
import React, { useState, useEffect } from 'react';
import { getBooks, createBook, updateBook, deleteBook } from './BookService';

function App() {
    const [books, setBooks] = useState([]);
    const [title, setTitle] = useState('');
    const [author, setAuthor] = useState('');
    const [page, setPage] = useState(0);
    const [size] = useState(5);
    const [totalPages, setTotalPages] = useState(0);

    const fetchBooks = () => {
        getBooks(title, author, page, size).then(res => {
            setBooks(res.data.content);
            setTotalPages(res.data.totalPages);
        });
    };

    useEffect(() => {
        fetchBooks();
    }, [page]);

    return (
        <div style={{ padding: 20 }}>
            <h1>Book Management</h1>
            <div>
                <input placeholder="Title" value={title} onChange={e => setTitle(e.target.value)} />
                <input placeholder="Author" value={author} onChange={e => setAuthor(e.target.value)} />
                <button onClick={() => fetchBooks()}>Search</button>
            </div>
            <table border="1" cellPadding="10" style={{ marginTop: 20 }}>
                <thead>
                    <tr>
                        <th>Title</th>
                        <th>Author</th>
                        <th>Genre</th>
                        <th>Price</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {books.map(b => (
                        <tr key={b.id}>
                            <td>{b.title}</td>
                            <td>{b.author}</td>
                            <td>{b.genre}</td>
                            <td>{b.price}</td>
                            <td>
                                <button onClick={() => deleteBook(b.id).then(fetchBooks)}>Delete</button>
                            </td>
                        </tr>
                    ))}
                </tbody>
            </table>
            <div style={{ marginTop: 10 }}>
                <button disabled={page <= 0} onClick={() => setPage(page - 1)}>Previous</button>
                <span> Page {page + 1} of {totalPages} </span>
                <button disabled={page >= totalPages - 1} onClick={() => setPage(page + 1)}>Next</button>
            </div>
        </div>
    );
}

export default App;
```

✅ This simple React app:

* Shows a **paginated list of books**.
* Has **search inputs** for title & author.
* Supports **delete** (you can expand to add/edit).

---

This setup is fully functional and can be extended for **Add/Edit forms, validation, and better UI**.

---

If you want, I can **also provide a fully working Add/Edit form integration in React** so candidates can test **all CRUD operations** from the UI.

Do you want me to do that next?

